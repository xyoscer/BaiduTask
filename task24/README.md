##任务目的

熟练JavaScript
学习树这种数据结构的基本知识

##任务描述

基于任务23，添加节点的选择、增加与删除的功能
点击某个节点元素，则该节点元素呈现一个特殊被选中的样式
增加一个删除按钮，当选中某个节点元素后，点击删除按钮，则将该节点及其所有子节点删除掉
增加一个输入框及一个“添加”按钮当选中某个节点元素后，点击增加按钮，
则在该节点下增加一个子节点，节点内容为输入框中内容，插入在其子节点的最后一个位置

##任务总结
   - 该任务实现了在树中搜索节点（先序遍历，或后序遍历），删除节点的操作；
   - 给每个元素添加点击事件，点击每一个元素，该元素呈现特殊被选中的样式，将
    该点击元素的事件利用事件委托到父元素上，点击时，只有这个元素显示样式，其他元素样式
    ```javascript
    
      for(var i=0;i<divs.length;i++){   
             if(target != divs[i]) {
                divs[i].style.backgroundColor = '#fff';

             }else {
               target.style.backgroundColor = "#00ffff";
             }
         } 
    ```
    


     - 当插入完数据，需要重新更新点击事件，这样才能使新增添加的节点也会有相应的响应事件
     - 删除节点，使用removeChild()函数，首先找到要删除节点的父元素parentNode,然后依次删除掉该节点的所有孩子节点，（使用childElemnetCount和firstElementChild和while语句来依次删除孩子节点），最终从父元素上是删除该节点，即完成删除该节点及所用子节点
     
 - 改进删除节点，直接找到要删除的节点的父元素，然后使用removeChild直接删除，这样也就删除了该节点以及其子节点
   
 + 使用removeChild()操作节点，该节点只是从当前的文档树中移除，但在内存中仍然存在。,因此,还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量来保存这个删除节点的引用 , 如果没有使用变量来保存对这个节点的引用, 则认为被移除的节点已经是无用的, 在短时间内将会被`内存管理`回收.
  
 + 插入节点，选中要插入节点的父节点，直接在其节点上面使用+=innerHTML
 
 ####js的内存管理机制
 
 
    *内存生命周期*
    
         1.分配所需要的内存 在定义变量，函数；或是调用某些函数(比如 new Date())时分配
         
         2.使用分配到的内存（读、写）  使用变量，对变量赋值，调用函数等情况
         
         3.不需要时将其释放\归还    垃圾回收
 
    *垃圾回收*
    
      
                JavaScript， 其在变量（对象，字符串等等）创建时分配内存，然后在它们不再使用时“自动”释放。称为垃圾回收，垃圾回收的机制：
                释放某段不再被引用的内存的算法
                
      *引用计数垃圾收集*
        
       把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收.
       
  ` 引用计数`的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
    如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值,
    则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。                
        
    限制：循环引用   两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，
    可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。
           
```javascript
function fun() {
   var obj1 = {};   //obj1引用值为1
   var obj2 = {};   //obj2引用值为1
   obj1.a = obj2;   //obj1引用值变为2
   obj2.a = obj1;   //obj2引用值变为2
}
```
当这个函数执行完后，两个对象还会继续存在，因为他们的引用次数不会是0，如果该函数被重复调用，就会导致大量内存得不到回收

    *标记-清除算法*
           
       这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，
       找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。
       
   `标记清除` 当变量进入环境（比如：在函数中声明一个变量）时，就将这个变量标记为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量
   所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们，而当变量离开环境时，则将其标记为“离开环境”。
   
```javascript

    function fun() {
       var a = 10 ;    //被标记 ，进入环境  
       var b = 20 ;    //被标记 ，进入环境
      
    }
    fun()   //执行完毕 之后 a、b又被标离开环境，被回收
```
        
           
